# SCL_FORWARD

Идентичный вариативный макрос, который пробрасывает токены без изменений и
часто используется для принудительной развёртки в цепочках макросов.

- Заголовок: `#include <scl/utility/preprocessor/forward.h>`
- Объявление: `#define SCL_FORWARD(...) __VA_ARGS__`

## Назначение

- Пробросить разделённые запятыми токены в другой макрос, вызов функции или
  список параметров шаблона, не меняя токенизацию.
- Форсировать развёртку, когда макрос возвращает набор токенов с запятыми,
  а следующий макрос должен их корректно «съесть».

Макрос не создаёт рантайм‑накладных расходов; работает только на этапе
препроцессирования.

## Примеры использования

```cpp
#include <scl/preprocessor.h>

// Проброс аргументов функции
#define CALL(fn, ...) fn(__VA_ARGS__)
int add(int a, int b) { return a + b; }
int result = CALL(add, SCL_FORWARD(1, 2)); // -> add(1, 2)

// Форсирование развёртки макроса, выдающего список типов
#define BASIC_TYPES int, long, double
template <typename... Ts>
struct type_list {};
using TL = type_list<SCL_FORWARD(BASIC_TYPES)>; // -> type_list<int, long, double>

// Цепочка макросов, производящих токены через запятую
#define MAKE_PAIR(a, b) a, b
using P = std::pair<SCL_FORWARD(MAKE_PAIR(int, double))>; // -> std::pair<int, double>

// Проброс аргументов через промежуточный макрос
#define FORWARD_TO_EMPLACE(obj, ...) obj.emplace_back(__VA_ARGS__)
std::vector<std::pair<int, std::string>> v;
FORWARD_TO_EMPLACE(v, SCL_FORWARD(42, "answer")); // -> emplace_back(42, "answer")
```

## Заметки и подводные камни

- SCL_FORWARD не добавляет скобок и не меняет группировку токенов. Если нужна
  группировка, используйте скобки на местах вызова.
- Он не превращает несколько аргументов в «один аргумент»; препроцессор всё
  равно делит по запятым на внешнем уровне макроса.
- Особенно полезен в цепочках макросов, где требуется промежуточная развёртка
  перед потреблением токенов следующим макросом.
